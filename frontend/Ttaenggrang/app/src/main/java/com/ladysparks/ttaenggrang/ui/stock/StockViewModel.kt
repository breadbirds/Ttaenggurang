package com.ladysparks.ttaenggrang.ui.stockimport android.util.Logimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.ladysparks.ttaenggrang.data.model.dto.NewsDtoimport com.ladysparks.ttaenggrang.data.model.dto.StockDtoimport com.ladysparks.ttaenggrang.data.model.dto.StockTransactionDtoimport com.ladysparks.ttaenggrang.data.model.dto.StockStudentDtoimport com.ladysparks.ttaenggrang.data.model.dto.StockStudentTransactionDtoimport com.ladysparks.ttaenggrang.data.model.dto.TransTypeimport com.ladysparks.ttaenggrang.data.remote.RetrofitUtilimport com.ladysparks.ttaenggrang.data.remote.RetrofitUtil.Companion.bankServiceimport com.ladysparks.ttaenggrang.data.remote.StockServiceimport com.ladysparks.ttaenggrang.ui.component.BaseTableRowModelimport com.ladysparks.ttaenggrang.util.SharedPreferencesUtilimport kotlinx.coroutines.launchclass StockViewModel : ViewModel() {    private val stockService: StockService = RetrofitUtil.stockService    //ì£¼ì‹ ì „ì²´ì¡°íšŒ    private val _stockList = MutableLiveData<List<StockDto>>()    val stockList: LiveData<List<StockDto>> get() = _stockList    //ì£¼ì‹ ë§¤ë„    private val _sellTransaction = MutableLiveData<StockTransactionDto?>()    val sellTransaction: LiveData<StockTransactionDto?> get() = _sellTransaction    //ì£¼ì‹ ë§¤ìˆ˜    private val _buyTransaction = MutableLiveData<StockTransactionDto?>()    val buyTransaction: LiveData<StockTransactionDto?> get() = _buyTransaction    // ì—ëŸ¬ë©”ì„¸ì§€    private val _errorMessage = MutableLiveData<String?>()    val errorMessage: LiveData<String?> get() = _errorMessage    //  ë‚´ ë³´ìœ  ì£¼ì‹ ìˆ˜ LiveData    private val _ownedStocks = MutableLiveData<List<StockStudentDto>>()    val ownedStocks: LiveData<List<StockStudentDto>> = _ownedStocks    // ì²«ë²ˆì§¸ ì•„ì´í…œ ë¶ˆëŸ¬ì˜¤ê¸°    private val _selectedStock = MutableLiveData<StockDto?>()    val selectedStock: LiveData<StockDto?> get() = _selectedStock    // ì£¼ì‹ ì—´ë¦¼ í™•ì¸    private val _isMarketActive = MutableLiveData<Boolean>()    val isMarketActive: LiveData<Boolean> get() = _isMarketActive    // ì‚¬ìš©ìê°€ ì…ë ¥í•œ ê±°ë˜ ì£¼ì‹ ìˆ˜    private val _tradeAmount = MutableLiveData<Int>()    val tradeAmount: LiveData<Int> get() = _tradeAmount    // ì˜ˆìƒ ê²°ì œ ê¸ˆì•¡    private val _expectedPayment = MutableLiveData<Int>()    val expectedPayment: LiveData<Int> get() = _expectedPayment    // ê±°ë˜ í›„ ë‚´ ë³´ìœ  í˜„ê¸ˆ ê³„ì‚°    private val _updatedBalance = MutableLiveData<Int>()    val updatedBalance: LiveData<Int> get() = _updatedBalance    // ê±°ë˜ í›„ ë‚´ ë³´ìœ  ì£¼ì‹ ìˆ˜    private val _updatedOwnedStock = MutableLiveData<Int>()    val updatedOwnedStock: LiveData<Int> get() = _updatedOwnedStock    // ê±°ë˜ ê°€ëŠ¥ í˜„ê¸ˆ    private val _balance = MutableLiveData<Int>()    val balance: LiveData<Int> get() = _balance    // í•™ìƒ ì£¼ì‹ ê±°ë˜ ê¸°ë¡    private val _stockTransaction = MutableLiveData<List<StockStudentTransactionDto>>()    val stockTransaction: LiveData<List<StockStudentTransactionDto>> get() = _stockTransaction    // í•™ìƒ ì£¼ì‹ ëª©ë¡ í…Œì´ë¸”    private val _stockTableData = MutableLiveData<List<BaseTableRowModel>>()    val stockTableData: LiveData<List<BaseTableRowModel>> get() = _stockTableData    // ì´ íˆ¬ìì•¡, í‰ê°€ê¸ˆì•¡, ìˆ˜ìµë¥  ë“±ì˜ ìš”ì•½ ì •ë³´ LiveData ì¶”ê°€    private val _stockSummary = MutableLiveData<Map<String, Any>>()    val stockSummary: LiveData<Map<String, Any>> get() = _stockSummary    // ì´ì „ ë‰´ìŠ¤ ê¸°ë¡ ì¡°íšŒ    // ë‰´ìŠ¤ ìƒì„±    private val _newsLiveData = MutableLiveData<NewsDto?>()    val newsLiveData: LiveData<NewsDto?> get() = _newsLiveData    // ì£¼ì‹ ë°ì´í„° ì¡°íšŒ    fun fetchAllStocks() = viewModelScope.launch {        runCatching {            stockService.getAllStocks()        }.onSuccess { stocks ->            _stockList.postValue(stocks)            if (stocks.isNotEmpty()) _selectedStock.postValue(stocks[0]) // ì£¼ì‹í™”ë©´ ë¡œë”©ë˜ë©´ ë°”ë¡œ 0ë²ˆì§¸ ì•„ì´í…œì„ ë…¸ì¶œ        }.onFailure { e ->            Log.e("StockViewModel", "ì£¼ì‹ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨", e)        }    }    // í•™ìƒì´ ë³´ìœ í•œ ì£¼ì‹ ëª©ë¡ ì¡°íšŒ    fun fetchOwnedStocks(studentId: Int) = viewModelScope.launch {        runCatching {            stockService.getStocksStudent(studentId)        }.onSuccess { stocks ->            _ownedStocks.postValue(stocks)            Log.d("TAG", "fetchOwnedStocks: í•™ìƒ ì£¼ì‹ ëª©ë¡ ì¡°íšŒì„±ê³µ!!!${stocks}")        }.onFailure { e ->            Log.e("StockViewModel", "ë³´ìœ  ì£¼ì‹ ì¡°íšŒ ì‹¤íŒ¨", e)            _ownedStocks.postValue(emptyList())        }    }    // ì£¼ì‹ ë§¤ë„    fun sellStock(stockId: Int, shareCount: Int, studentId: Int) = viewModelScope.launch {        runCatching {            stockService.sellStock(stockId, shareCount, studentId)        }.onSuccess { response ->            // ì‚¬ìš©ìê°€ ì…ë ¥í•œ ê°’ì„ totalAmtì— ë„£ìŒ            val transactionData = response.body()?.data            // ë°ì´í„° ë™ê¸°í™”            _sellTransaction.postValue(transactionData)            fetchBalance()        }.onFailure { e ->            Log.e("StockViewModel", "ë§¤ë„ ìš”ì²­ ì‹¤íŒ¨", e)            _errorMessage.postValue("ë§¤ë„ ìš”ì²­ ì‹¤íŒ¨: ${e.message}")        }    }    // ë§¤ìˆ˜ ê¸°ëŠ¥    fun buyStock(stockId: Int, shareCount: Int, studentId: Int) = viewModelScope.launch {        runCatching {            stockService.buyStock(stockId, shareCount, studentId)        }.onSuccess { response ->            val transactionData = response.body()?.data            //ë°ì´í„° ë™ê¸°í™”            _buyTransaction.postValue(transactionData)            Log.d("StockViewModel", "ë§¤ìˆ˜ ì„±ê³µ: ${response.body()?.data?.shareCount}ì£¼")            fetchBalance()        }.onFailure { e ->            Log.e("StockViewModel", "ë§¤ìˆ˜ ìš”ì²­ ì‹¤íŒ¨", e)            _errorMessage.postValue("ë§¤ìˆ˜ ìš”ì²­ ì‹¤íŒ¨: ${e.message}")        }    }    // âœ… íŠ¹ì • ì£¼ì‹ ì„ íƒ (ë¦¬ì‚¬ì´í´ëŸ¬ë·°ì—ì„œ í´ë¦­ ì‹œ í˜¸ì¶œë¨)    fun selectStock(stock: StockDto) {        _selectedStock.value = stock    }    //ì£¼ì‹ì¥ ì—´ê¸°(êµì‚¬)    fun updateMarketStatus(openMarket: Boolean) = viewModelScope.launch {        runCatching {            stockService.setMarketStatus(openMarket)        }.onSuccess { response ->            _isMarketActive.postValue(response.body()?.data ?: false)        }.onFailure {            _isMarketActive.postValue(false)        }    }    // ì£¼ì‹ì¥ ì—´ë¦¼ í™•ì¸(í•™ìƒ). ë³€ê²½ì‚¬í•­ì´ ìˆì„ë•Œë§Œ ui ì—…ë°ì´íŠ¸    fun fetchMarketStatus() = viewModelScope.launch {        runCatching {            stockService.getMarketStatus()        }.onSuccess { response ->            val newStatus = response.body()?.data ?: false            if (_isMarketActive.value != newStatus) {                _isMarketActive.postValue(newStatus)            }        }.onFailure {            _isMarketActive.postValue(false)        }    }    // confirmDialog ì—ì„œ ê³„ì‚°ì„ ìœ„í•œ ë·°ëª¨ë¸    fun updateTradeAmount(        amount: Int,        stockPrice: Int,        ownedStock: Int,        transactionType: TransType    ) {        _tradeAmount.postValue(amount)        val calculatedPayment = stockPrice * amount        _expectedPayment.postValue(calculatedPayment)        _updatedBalance.postValue(            if (transactionType == TransType.SELL) (_balance.value ?: 0) + calculatedPayment            else (_balance.value ?: 0) - calculatedPayment        )        _updatedOwnedStock.postValue(            if (transactionType == TransType.SELL) ownedStock - amount            else ownedStock + amount        )    }    // ì£¼ì‹ í™”ë©´ì— ê±°ë˜ê°€ëŠ¥ í˜„ê¸ˆ í‘œì‹œ    fun fetchBalance() = viewModelScope.launch {        runCatching {            bankService.getBankAccount()        }.onSuccess { response ->            Log.d("StockViewModel", "fetchBalance: ${response.body()?.data?.balance}")            _balance.postValue(response.body()?.data?.balance ?: 0)        }.onFailure { e ->            Log.e("StockViewModel", "ê±°ë˜ ê°€ëŠ¥ í˜„ê¸ˆ ì¡°íšŒ ì‹¤íŒ¨", e)            _balance.postValue(0)        }    }    // í•™ìƒ ì£¼ì‹ ê±°ë˜ ê¸°ë¡ ì¡°íšŒ    fun fetchStudentStockTransactions(studentId: Int) = viewModelScope.launch {        runCatching {            stockService.getStockStudentTransaction(studentId)        }.onSuccess { transactions ->            Log.d("TAG", "fetchStudentStockTransactions: ${transactions}}")            // âœ… ê°œë³„ ê±°ë˜ ë¡œê·¸ ì¶œë ¥            transactions.forEach { transaction ->                Log.d(                    "TAG", "ê±°ë˜ ê¸°ë¡ - í•™ìƒID: ${transaction.studentId}, " +                            "ì£¼ì‹ID: ${transaction.stockId}, " +                            "ê±°ë˜ìœ í˜•: ${transaction.transType}, " +                            "ê±°ë˜ìˆ˜ëŸ‰: ${transaction.shareCount}, " +                            "ê±°ë˜ë‚ ì§œ: ${transaction.transDate}, " +                            "ë§¤ì…ê°€ê²©: ${transaction.purchasePrice}, " +                            "ì£¼ì‹ëª…: ${transaction.stockName}, " +                            "ì£¼ì‹ìœ í˜•: ${transaction.stockType}"                )            }            _stockTransaction.postValue(transactions)        }.onFailure { e ->            Log.e("TAG", "fetchStudentStockTransactions ì‹¤íŒ¨: ${e.message}", e)            // âœ… ì‹¤íŒ¨ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜í•˜ì—¬ UIì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥í•˜ë„ë¡ í•¨            _stockTransaction.postValue(emptyList())        }    }//    // í•™ìƒ ì£¼ì‹ ëª©ë¡ í…Œì´ë¸” ê³„ì‚°//    fun updateStockTableData(studentId: Int) {//        val ownedStocks = ownedStocks.value ?: emptyList()//        val transactions = stockTransaction.value ?: emptyList()////        val newData = ownedStocks.map { stock ->//            val matchingTransaction = transactions.find { it.stockId == stock.stockId }//            val stockType = matchingTransaction?.stockType ?: "ì•Œ ìˆ˜ ì—†ìŒ" // âœ… ì£¼ì‹ ìœ í˜• ê°€ì ¸ì˜¤ê¸°////            // í‰ê·  ë§¤ì… ë‹¨ê°€ ê³„ì‚°//            // ë§¤ìˆ˜í•œ ì£¼ì‹ ìˆ˜ í•©ì‚° ( ë³´ìœ  ì£¼ì‹)//            val totalShares = transactions//                .filter { it.stockId == stock.stockId && it.transType == TransType.BUY } // ğŸ”¥ ë§¤ìˆ˜ ê±°ë˜ë§Œ í•„í„°ë§//                .sumOf { it.shareCount }//            Log.d("TAG", "updateStockTableData: ë‚´ê°€ êµ¬ë§¤í•œ ì£¼ì‹ ìˆ˜ $totalShares")////            // 2ï¸ë§¤ìˆ˜í•œ ì£¼ì‹ë“¤ì˜ ì´ ë§¤ì… ê¸ˆì•¡//            val totalCost = transactions//                .filter { it.stockId == stock.stockId && it.transType == TransType.BUY } // ğŸ”¥ ë§¤ìˆ˜ ê±°ë˜ë§Œ í•„í„°ë§//                .sumOf { it.shareCount * it.purchasePrice }//            val filteredTransactions = transactions.filter {//                it.stockId == stock.stockId && it.transType == TransType.BUY//            }//////            // ê°œë³„ ê±°ë˜ ë¡œê·¸ ì¶œë ¥ (ë§¤ìˆ˜ ê±°ë˜ë§Œ í•„í„°ë§)////            filteredTransactions.forEach { transaction ->////                Log.d("StockViewModel", "ë§¤ìˆ˜ ê±°ë˜ - ì£¼ì‹ID: ${transaction.stockId}, ê±°ë˜ ìˆ˜ëŸ‰: ${transaction.shareCount}, ë§¤ì…ê°€: ${transaction.purchasePrice}, ê³„ì‚° ê°’: ${transaction.shareCount * transaction.purchasePrice}")////            }////            // ë¡œê·¸ë¡œ ìµœì¢… ì´ ë§¤ì… ê¸ˆì•¡ í™•ì¸////            Log.d("StockViewModel", "ì´ ë§¤ì… ê¸ˆì•¡: $totalCost")////            // í‰ê·  ë§¤ì… ë‹¨ê°€ ê³„ì‚° (ì´ ë§¤ì… ê¸ˆì•¡ / ì´ ë§¤ì… ì£¼ì‹ ìˆ˜)//            val avgPurchasePrice = if (totalShares > 0) totalCost / totalShares else 0////            // í‰ê°€ê¸ˆì•¡ ê³„ì‚°//            val valuationAmount = stock.ownedQty * stock.currentPrice////            // ì†ìµê¸ˆì•¡ ê³„ì‚°//            val profitLoss = valuationAmount - (avgPurchasePrice * stock.ownedQty)////            // ìˆ˜ìµë¥  ê³„ì‚°//            val yield = if (avgPurchasePrice > 0) {//                (profitLoss.toFloat() / (avgPurchasePrice * stock.ownedQty)) * 100//            } else 0f//////            BaseTableRowModel(//                listOf(//                    stock.purchaseDate,      // ë§¤ìˆ˜ì¼//                    stock.stockName,         // ì£¼ì‹ëª…//                    stockType,               // stockStudentTransactionì—ì„œ ê°€ì ¸ì˜¨ ì£¼ì‹ ìœ í˜•//                    stock.ownedQty.toString(),  // ë³´ìœ  ì£¼ì‹ ìˆ˜//                    avgPurchasePrice.toString(), // í‰ê·  ë§¤ì… ë‹¨ê°€//                    stock.currentPrice.toString(), // í˜„ì¬ ì£¼ê°€//                    valuationAmount.toString(), // í‰ê°€ê¸ˆì•¡//                    "%.2f%%".format(yield), // ìˆ˜ìµë¥ //                    profitLoss.toString() // ì†ìµê¸ˆì•¡//                )//            )//        }////        _stockTableData.postValue(newData)//    }    // í•™ìƒ ì£¼ì‹ ëª©ë¡ í…Œì´ë¸” ê³„ì‚°    fun updateStockTableData(studentId: Int) {        val ownedStocks = ownedStocks.value ?: emptyList()        val transactions = stockTransaction.value ?: emptyList()        var totalInvestment = 0 // âœ… ì´ íˆ¬ìì•¡        var totalValuation = 0 // âœ… ì´ í‰ê°€ê¸ˆì•¡        val newData = ownedStocks.map { stock ->            val matchingTransaction = transactions.find { it.stockId == stock.stockId }            val stockType = matchingTransaction?.stockType ?: "ì•Œ ìˆ˜ ì—†ìŒ" // âœ… ì£¼ì‹ ìœ í˜• ê°€ì ¸ì˜¤ê¸°            // âœ… ë§¤ìˆ˜í•œ ì£¼ì‹ ìˆ˜ í•©ì‚° (ë³´ìœ  ì£¼ì‹)            val totalShares = transactions                .filter { it.stockId == stock.stockId && it.transType == TransType.BUY } // ğŸ”¥ ë§¤ìˆ˜ ê±°ë˜ë§Œ í•„í„°ë§                .sumOf { it.shareCount }            Log.d("StockDebug", "ì£¼ì‹ ${stock.stockName} - ë§¤ìˆ˜í•œ ì£¼ì‹ ì´ ê°œìˆ˜: $totalShares")            // âœ… ë§¤ìˆ˜í•œ ì£¼ì‹ë“¤ì˜ ì´ ë§¤ì… ê¸ˆì•¡            val totalCost = transactions                .filter { it.stockId == stock.stockId && it.transType == TransType.BUY } // ğŸ”¥ ë§¤ìˆ˜ ê±°ë˜ë§Œ í•„í„°ë§                .sumOf { it.shareCount * it.purchasePrice }            Log.d("StockDebug", "ì£¼ì‹ ${stock.stockName} - ì´ ë§¤ì… ê¸ˆì•¡: $totalCost")            // âœ… í‰ê·  ë§¤ì… ë‹¨ê°€ ê³„ì‚° (ì´ ë§¤ì… ê¸ˆì•¡ / ì´ ë§¤ì… ì£¼ì‹ ìˆ˜)            val avgPurchasePrice = if (totalShares > 0) totalCost / totalShares else 0            Log.d("StockDebug", "ì£¼ì‹ ${stock.stockName} - í‰ê·  ë§¤ì… ë‹¨ê°€: $avgPurchasePrice")            // âœ… í‰ê°€ê¸ˆì•¡ ê³„ì‚° (ë³´ìœ  ì£¼ì‹ ìˆ˜ * í˜„ì¬ ì£¼ê°€)            val valuationAmount = stock.ownedQty * stock.currentPrice            Log.d("StockDebug", "ì£¼ì‹ ${stock.stockName} - í‰ê°€ê¸ˆì•¡: $valuationAmount")            // âœ… ì†ìµê¸ˆì•¡ ê³„ì‚° (í‰ê°€ê¸ˆì•¡ - íˆ¬ìê¸ˆì•¡)            val investmentAmount = stock.ownedQty * avgPurchasePrice            val profitLoss = valuationAmount - investmentAmount            Log.d("StockDebug", "ì£¼ì‹ ${stock.stockName} - ì†ìµê¸ˆì•¡: $profitLoss")            // âœ… ìˆ˜ìµë¥  ê³„ì‚°            val yield = if (investmentAmount > 0) {                (profitLoss.toFloat() / investmentAmount) * 100            } else 0f            Log.d("StockDebug", "ì£¼ì‹ ${stock.stockName} - ìˆ˜ìµë¥ : %.2f%%".format(yield))            // âœ… ì´ íˆ¬ìì•¡ê³¼ ì´ í‰ê°€ê¸ˆì•¡ ì—…ë°ì´íŠ¸            totalInvestment += investmentAmount            totalValuation += valuationAmount            BaseTableRowModel(                listOf(                    stock.purchaseDate,      // ë§¤ìˆ˜ì¼                    stock.stockName,         // ì£¼ì‹ëª…                    stockType,               // âœ… ì£¼ì‹ ìœ í˜•                    stock.ownedQty.toString(),  // ë³´ìœ  ì£¼ì‹ ìˆ˜                    avgPurchasePrice.toString(), // âœ… í‰ê·  ë§¤ì… ë‹¨ê°€                    stock.currentPrice.toString(), // í˜„ì¬ ì£¼ê°€                    valuationAmount.toString(), // âœ… í‰ê°€ê¸ˆì•¡                    "%.2f%%".format(yield), // ìˆ˜ìµë¥                     profitLoss.toString() // ì†ìµê¸ˆì•¡                )            )        }        // âœ… ì´ ìˆ˜ìµ & ì´ ìˆ˜ìµë¥  ê³„ì‚°        val totalProfit = totalValuation - totalInvestment        val totalReturnRate =            if (totalInvestment > 0) (totalProfit.toFloat() / totalInvestment) * 100 else 0f        Log.d("StockSummary", "ì´ íˆ¬ìì•¡: $totalInvestment")        Log.d("StockSummary", "ì´ í‰ê°€ê¸ˆì•¡: $totalValuation")        Log.d("StockSummary", "ì´ ìˆ˜ìµ: $totalProfit")        Log.d("StockSummary", "ì´ ìˆ˜ìµë¥ : %.2f%%".format(totalReturnRate))        // âœ… ì´ íˆ¬ìì•¡, í‰ê°€ê¸ˆì•¡, ìˆ˜ìµë¥  LiveData ì—…ë°ì´íŠ¸        _stockSummary.postValue(            mapOf(                "totalInvestment" to totalInvestment,                "totalValuation" to totalValuation,                "totalProfit" to totalProfit,                "totalReturnRate" to totalReturnRate            )        )        _stockTableData.postValue(newData)    }    // ë‰´ìŠ¤ ìƒì„±    //í† í° ìœ ë¬´ ë‹¤ì‹œ í™•ì¸    fun createNews() {        viewModelScope.launch {            runCatching {                val token = SharedPreferencesUtil.getValue(SharedPreferencesUtil.JWT_TOKEN_KEY, "") // âœ… í† í° ê°€ì ¸ì˜¤ê¸°                stockService.createNews("Bearer $token") // âœ… ë°”ë”” ì—†ì´ POST ìš”ì²­            }.onSuccess { response ->                if (response.statusCode == 0) {                    _newsLiveData.postValue(response.data)                    Log.d("NewsViewModel", "ë‰´ìŠ¤ ìƒì„± ì„±ê³µ: ${response.data}")                } else {                    _errorMessage.postValue("ë‰´ìŠ¤ ìƒì„± ì‹¤íŒ¨: ${response.message}")                }            }.onFailure { e ->                _errorMessage.postValue("ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë°œìƒ: ${e.message}")                Log.e("NewsViewModel", "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜", e)            }        }    }}